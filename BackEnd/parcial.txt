--------------
0 - int - retorno
1 - int - a
2 - int - b
3 - int - T6
--------------
proc cociente_int_int(){
T1=p+1
T2=pila[T1]	//saco a
T3=p+2
T4=pila[T3]	//saco b
If T2 < T4 goto L1
goto L2


L1:
T5=p+0		//posiciÃ³n en stack de return
Pila[T5]=0
Goto L4		//debido al return se hace este salto
Goto L3		//para no entrar en else


L2:
T6=p+0  //posicion en stack return      --T6
T7=p+1
T8=pila[T7] //saco a
T9=p+2
T10=pila[T9] //saco b
T11 = T8-T10    //a-b
T12=p+2
T13=pila[T12] //saco b
T14=p+3
pila[T14]=T6    //bckup de T6 posicion a guardar
T15=p+4            //paso de params fuera de ambto actual
T16=T15+1           //paso de params pos a
pila[T16]=T11
T17=T15+2           //paso de params pos b
pila[T17]=T13
p=p+4               //cambio de ambito formal
---------
call cociente_int_int()
---------
T18=p+0
T19=pila[T18]   //obtengo el retorno de mi llamada a funcion
p=p-4           //regreso de mi antiguo ambito
T20=p+3
T6=pila[T20]    //recuperamos T6
T21=1+T19       //1 + cociente(a - b, b)
pila[T6]=T21    //asigno a return la llamada recursiva +1
goto L5
L3:
L4,L5:	//return exit
}


--------------
0 - int - i
1 - int - n
2 - int - cont
3 - int[] - vec
_____________________
|  i1=1 | 
|  s1=10 | 
|  n1=10 |
-----------------
| vec[i]
| (i-i1)
_____________________
proc recorre(){
T22=p+2     //posicion en stack de cont
T23=p+1
T24=pila[T23]   // obtengo a n

T25=p+0         //saco para indice i
T26=pila[T25]   //saque a i de pila q es el index para vec 
T27=T26-1       //(i-i1)
T28=vec[T27]    //obtengo en posicion i del array vec
T29=p+4
T30=T29+1               
pila[T30]=T28   //paso de params pos a -> vec[i]
T31=T29+2         
pila[T31]=T24   //paso de params pos b -> n

p=p+4           //cambio de ambito formal
-----
call cociente_int_int()
-----
T32=p+0
T33=pila[T32]   //obtengo el retorno de mi llamada a funcion
p=p-4           //regreso de mi antiguo ambito
pila[T22]=T33   //Cont = cociente(vec[i], n)

}